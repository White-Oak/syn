var searchIndex = {};
searchIndex["syn"] = {"doc":"","items":[[3,"Attribute","syn","",null,null],[12,"value","","",0,null],[12,"is_sugared_doc","","",0,null],[3,"Generics","","",null,null],[12,"lifetimes","","",1,null],[12,"ty_params","","",1,null],[12,"where_clause","","",1,null],[3,"Lifetime","","",null,null],[12,"ident","","",2,null],[3,"LifetimeDef","","",null,null],[12,"lifetime","","",3,null],[12,"bounds","","",3,null],[3,"TyParam","","",null,null],[12,"ident","","",4,null],[12,"bounds","","",4,null],[12,"default","","",4,null],[3,"WhereBoundPredicate","","A type bound.",null,null],[12,"bound_lifetimes","","Any lifetimes from a `for` binding",5,null],[12,"bounded_ty","","The type being bounded",5,null],[12,"bounds","","Trait and lifetime bounds (`Clone+Send+&#39;static`)",5,null],[3,"WhereClause","","",null,null],[12,"predicates","","",6,null],[3,"WhereRegionPredicate","","A lifetime predicate.",null,null],[12,"lifetime","","",7,null],[12,"bounds","","",7,null],[3,"Ident","","",null,null],[3,"Field","","",null,null],[12,"ident","","",8,null],[12,"vis","","",8,null],[12,"attrs","","",8,null],[12,"ty","","",8,null],[3,"Item","","",null,null],[12,"ident","","",9,null],[12,"vis","","",9,null],[12,"attrs","","",9,null],[12,"generics","","",9,null],[12,"body","","",9,null],[3,"Variant","","",null,null],[12,"ident","","",10,null],[12,"attrs","","",10,null],[12,"data","","",10,null],[3,"AngleBracketedParameterData","","A path like `Foo&lt;&#39;a, T&gt;`",null,null],[12,"lifetimes","","The lifetime parameters for this path segment.",11,null],[12,"types","","The type parameters for this path segment, if present.",11,null],[12,"bindings","","Bindings (equality constraints) on associated types, if present.",11,null],[3,"BareFnTy","","",null,null],[12,"lifetimes","","",12,null],[12,"decl","","",12,null],[3,"FnArg","","An argument in a function header.",null,null],[12,"pat","","",13,null],[12,"ty","","",13,null],[3,"FnDecl","","Header (not the body) of a function declaration.",null,null],[12,"inputs","","",14,null],[12,"output","","",14,null],[3,"MutTy","","",null,null],[12,"ty","","",15,null],[12,"mutability","","",15,null],[3,"ParenthesizedParameterData","","A path like `Foo(A,B) -&gt; C`",null,null],[12,"inputs","","`(A, B)`",16,null],[12,"output","","`C`",16,null],[3,"Path","","",null,null],[12,"global","","",17,null],[12,"segments","","",17,null],[3,"PathSegment","","A segment of a path: an identifier, an optional lifetime, and a set of types.",null,null],[12,"ident","","",18,null],[12,"parameters","","",18,null],[3,"PolyTraitRef","","",null,null],[12,"bound_lifetimes","","The `&#39;a` in `&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;`",19,null],[12,"trait_ref","","The `Foo&lt;&amp;&#39;a T&gt;` in `&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;`",19,null],[3,"QSelf","","The explicit Self type in a &quot;qualified path&quot;. The actual\npath, including the trait and the associated item, is stored\nseparately. `position` represents the index of the associated\nitem qualified with this Self type.",null,null],[12,"ty","","",20,null],[12,"position","","",20,null],[3,"TypeBinding","","Bind a type to an associated type: `A=Foo`.",null,null],[12,"ident","","",21,null],[12,"ty","","",21,null],[4,"MetaItem","","A compile-time attribute item.",null,null],[13,"Word","","Word meta item.",22,null],[13,"List","","List meta item.",22,null],[13,"NameValue","","Name value meta item.",22,null],[4,"TraitBoundModifier","","",null,null],[13,"None","","",23,null],[13,"Maybe","","",23,null],[4,"TyParamBound","","",null,null],[13,"Trait","","",24,null],[13,"Region","","",24,null],[4,"WherePredicate","","A single predicate in a `where` clause",null,null],[13,"BoundPredicate","","A type binding, e.g. `for&lt;&#39;c&gt; Foo: Send+Clone+&#39;c`",25,null],[13,"RegionPredicate","","A lifetime predicate, e.g. `&#39;a: &#39;b+&#39;c`",25,null],[4,"Body","","",null,null],[13,"Enum","","",26,null],[13,"Struct","","",26,null],[4,"VariantData","","",null,null],[13,"Struct","","",27,null],[13,"Tuple","","",27,null],[13,"Unit","","",27,null],[4,"Visibility","","",null,null],[13,"Public","","",28,null],[13,"Inherited","","",28,null],[4,"FunctionRetTy","","",null,null],[13,"Default","","Return type is not specified.",29,null],[13,"Ty","","Everything else",29,null],[4,"Mutability","","",null,null],[13,"Mutable","","",30,null],[13,"Immutable","","",30,null],[4,"PathParameters","","Parameters of a path segment.",null,null],[13,"AngleBracketed","","The `&lt;&#39;a, A, B, C&gt;` in `foo::bar::baz::&lt;&#39;a, A, B, C&gt;`",31,null],[13,"Parenthesized","","The `(A, B)` and `C` in `Foo(A, B) -&gt; C`",31,null],[4,"Ty","","",null,null],[13,"Vec","","A variable-length array (`[T]`)",32,null],[13,"FixedLengthVec","","A fixed length array (`[T; n]`)",32,null],[13,"Ptr","","A raw pointer (`*const T` or `*mut T`)",32,null],[13,"Rptr","","A reference (`&amp;&#39;a T` or `&amp;&#39;a mut T`)",32,null],[13,"BareFn","","A bare function (e.g. `fn(usize) -&gt; bool`)",32,null],[13,"Never","","The never type (`!`)",32,null],[13,"Tup","","A tuple (`(A, B, C, D, ...)`)",32,null],[13,"Path","","A path (`module::module::...::Type`), optionally\n&quot;qualified&quot;, e.g. `&lt;Vec&lt;T&gt; as SomeTrait&gt;::SomeType`.",32,null],[13,"ObjectSum","","Something like `A+B`. Note that `B` must always be a path.",32,null],[13,"PolyTraitRef","","A type like `for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a Bar&gt;`",32,null],[13,"ImplTrait","","An `impl TraitA+TraitB` type.",32,null],[13,"Paren","","No-op; kept solely so that we can pretty-print faithfully",32,null],[13,"Infer","","TyKind::Infer means the type should be inferred instead of it having been\nspecified. This can appear anywhere in a type.",32,null],[5,"parse_item","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_type","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_path","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_where_clause","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"to_tokens","","",0,null],[11,"to_tokens","","",22,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",22,null],[11,"clone","","",22,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"to_tokens","","",1,null],[11,"to_tokens","","",2,null],[11,"to_tokens","","",3,null],[11,"to_tokens","","",4,null],[11,"to_tokens","","",24,null],[11,"to_tokens","","",6,null],[11,"to_tokens","","",25,null],[11,"to_tokens","","",5,null],[11,"to_tokens","","",7,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"generics"}}],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"fmt","","",24,null],[11,"clone","","",24,null],[11,"eq","","",24,null],[11,"ne","","",24,null],[11,"fmt","","",23,null],[11,"clone","","",23,null],[11,"eq","","",23,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"default","","",6,{"inputs":[],"output":{"name":"whereclause"}}],[11,"fmt","","",25,null],[11,"clone","","",25,null],[11,"eq","","",25,null],[11,"ne","","",25,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"to_tokens","","",33,null],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"hash","","",33,null],[11,"new","","",33,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"from","","",33,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",33,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"as_ref","","",33,null],[11,"fmt","","",33,null],[11,"eq","","",33,null],[11,"to_tokens","","",9,null],[11,"to_tokens","","",26,null],[11,"to_tokens","","",10,null],[11,"to_tokens","","",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"fmt","","",27,null],[11,"clone","","",27,null],[11,"eq","","",27,null],[11,"ne","","",27,null],[11,"fields","","",27,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"fmt","","",28,null],[11,"clone","","",28,null],[11,"eq","","",28,null],[11,"to_tokens","","",32,null],[11,"to_tokens","","",17,null],[11,"to_tokens","","",18,null],[11,"to_tokens","","",31,null],[11,"to_tokens","","",11,null],[11,"to_tokens","","",21,null],[11,"to_tokens","","",16,null],[11,"to_tokens","","",19,null],[11,"to_tokens","","",12,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"fmt","","",30,null],[11,"clone","","",30,null],[11,"eq","","",30,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"ident","","",18,{"inputs":[{"name":"ident"}],"output":{"name":"self"}}],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"none","","",31,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"default","","",11,{"inputs":[],"output":{"name":"anglebracketedparameterdata"}}],[11,"fmt","","",21,null],[11,"clone","","",21,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"eq","","",19,null],[11,"ne","","",19,null],[11,"fmt","","",20,null],[11,"clone","","",20,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"fmt","","",29,null],[11,"clone","","",29,null],[11,"eq","","",29,null],[11,"ne","","",29,null]],"paths":[[3,"Attribute"],[3,"Generics"],[3,"Lifetime"],[3,"LifetimeDef"],[3,"TyParam"],[3,"WhereBoundPredicate"],[3,"WhereClause"],[3,"WhereRegionPredicate"],[3,"Field"],[3,"Item"],[3,"Variant"],[3,"AngleBracketedParameterData"],[3,"BareFnTy"],[3,"FnArg"],[3,"FnDecl"],[3,"MutTy"],[3,"ParenthesizedParameterData"],[3,"Path"],[3,"PathSegment"],[3,"PolyTraitRef"],[3,"QSelf"],[3,"TypeBinding"],[4,"MetaItem"],[4,"TraitBoundModifier"],[4,"TyParamBound"],[4,"WherePredicate"],[4,"Body"],[4,"VariantData"],[4,"Visibility"],[4,"FunctionRetTy"],[4,"Mutability"],[4,"PathParameters"],[4,"Ty"],[3,"Ident"]]};
searchIndex["nom"] = {"doc":"nom, eating data byte by byte","items":[[3,"ProducerRepeat","nom","ProducerRepeat takes a single value, and generates it at each step",null,null],[3,"MemProducer","","A MemProducer generates values from an in memory byte buffer",null,null],[3,"FileProducer","","",null,null],[3,"MapConsumer","","MapConsumer takes a function S -&gt; T and applies it on a consumer producing values of type S",null,null],[3,"ChainConsumer","","ChainConsumer takes a consumer C1 R -&gt; S, and a consumer C2 S -&gt; T, and makes a consumer R -&gt; T by applying C2 on C1&#39;s result",null,null],[4,"ErrorKind","","indicates which parser returned an error",null,null],[13,"Custom","","",0,null],[13,"Tag","","",0,null],[13,"MapRes","","",0,null],[13,"MapOpt","","",0,null],[13,"Alt","","",0,null],[13,"IsNot","","",0,null],[13,"IsA","","",0,null],[13,"SeparatedList","","",0,null],[13,"SeparatedNonEmptyList","","",0,null],[13,"Many0","","",0,null],[13,"Many1","","",0,null],[13,"Count","","",0,null],[13,"TakeUntilAndConsume","","",0,null],[13,"TakeUntil","","",0,null],[13,"TakeUntilEitherAndConsume","","",0,null],[13,"TakeUntilEither","","",0,null],[13,"LengthValue","","",0,null],[13,"TagClosure","","",0,null],[13,"Alpha","","",0,null],[13,"Digit","","",0,null],[13,"HexDigit","","",0,null],[13,"OctDigit","","",0,null],[13,"AlphaNumeric","","",0,null],[13,"Space","","",0,null],[13,"MultiSpace","","",0,null],[13,"LengthValueFn","","",0,null],[13,"Eof","","",0,null],[13,"ExprOpt","","",0,null],[13,"ExprRes","","",0,null],[13,"CondReduce","","",0,null],[13,"Switch","","",0,null],[13,"TagBits","","",0,null],[13,"OneOf","","",0,null],[13,"NoneOf","","",0,null],[13,"Char","","",0,null],[13,"CrLf","","",0,null],[13,"RegexpMatch","","",0,null],[13,"RegexpMatches","","",0,null],[13,"RegexpFind","","",0,null],[13,"RegexpCapture","","",0,null],[13,"RegexpCaptures","","",0,null],[13,"TakeWhile1","","",0,null],[13,"Complete","","",0,null],[13,"Fix","","",0,null],[13,"Escaped","","",0,null],[13,"EscapedTransform","","",0,null],[13,"TagStr","","",0,null],[13,"IsNotStr","","",0,null],[13,"IsAStr","","",0,null],[13,"TakeWhile1Str","","",0,null],[13,"NonEmpty","","",0,null],[13,"ManyMN","","",0,null],[13,"TakeUntilAndConsumeStr","","",0,null],[13,"TakeUntilStr","","",0,null],[13,"Not","","",0,null],[4,"Err","","Contains the error that a parser can return",null,null],[13,"Code","","An error code, represented by an ErrorKind, which can contain a custom error code represented by E",1,null],[13,"Node","","An error code, and the next error",1,null],[13,"Position","","An error code, and the input position",1,null],[13,"NodePosition","","An error code, the input position and the next error",1,null],[4,"Needed","","Contains information on needed data if a parser returned `Incomplete`",null,null],[13,"Unknown","","needs more data, but we do not know how much",2,null],[13,"Size","","contains the required data size",2,null],[4,"IResult","","Holds the result of parsing functions",null,null],[13,"Done","","indicates a correct parsing, the first field containing the rest of the unparsed data, the second field contains the parsed data",3,null],[13,"Error","","contains a Err, an enum that can indicate an error code, a position in the input, and a pointer to another error, making a list of errors in the parsing tree",3,null],[13,"Incomplete","","Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown",3,null],[4,"Input","","",null,null],[13,"Element","","",4,null],[13,"Empty","","",4,null],[13,"Eof","","",4,null],[4,"ConsumerState","","Stores a consumer&#39;s current computation state",null,null],[13,"Done","","A value of type O has been produced",5,null],[13,"Error","","An error of type E has been encountered",5,null],[13,"Continue","","Continue applying, and pass a message of type M to the data source",5,null],[4,"Move","","",null,null],[13,"Consume","","indcates how much data was consumed",6,null],[13,"Seek","","indicates where in the input the consumer must seek",6,null],[13,"Await","","indicates more data is needed",6,null],[4,"FileProducerState","","",null,null],[13,"Normal","","",7,null],[13,"Error","","",7,null],[13,"Eof","","",7,null],[5,"error_to_list","","",null,{"inputs":[{"name":"err"}],"output":{"name":"vec"}}],[5,"compare_error_paths","","",null,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[5,"add_error_pattern","","",null,{"inputs":[{"name":"hashmap"},{"name":"iresult"},{"name":"str"}],"output":{"name":"bool"}}],[5,"slice_to_offsets","","",null,null],[5,"prepare_errors","","",null,null],[5,"print_error","","",null,null],[5,"generate_colors","","",null,null],[5,"code_from_offset","","",null,null],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"print_codes","","",null,{"inputs":[{"name":"hashmap"},{"name":"hashmap"}],"output":{"name":"string"}}],[5,"print_offsets","","",null,null],[5,"error_to_u32","","",null,{"inputs":[{"name":"errorkind"}],"output":{"name":"u32"}}],[5,"tag_cl","","",null,null],[5,"print","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"begin","","",null,null],[5,"not_line_ending","","",null,null],[5,"line_ending","","Recognizes a line feed",null,null],[5,"is_alphabetic","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_hex_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_oct_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes lowercase and uppercase alphabetic characters: a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"digit","","Recognizes numerical characters: 0-9",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"hex_digit","","Recognizes hexadecimal numerical characters: 0-9, A-F, a-f",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"oct_digit","","Recognizes octal characters: 0-7",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"alphanumeric","","Recognizes numerical and alphabetic characters: 0-9a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"space","","Recognizes spaces and tabs",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"multispace","","Recognizes spaces, tabs, carriage returns and line feeds",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"sized_buffer","","",null,null],[5,"length_value","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"le_f32","","Recognizes little endian 4 bytes floating point number",null,null],[5,"le_f64","","Recognizes little endian 8 bytes floating point number",null,null],[5,"hex_u32","","Recognizes a hex-encoded integer",null,null],[5,"eof","","Recognizes empty input buffers",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"non_empty","","Recognizes non empty buffers",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"rest","","Return the remaining input.",null,null],[5,"rest_s","","Return the remaining input, for strings.",null,{"inputs":[{"name":"str"}],"output":{"name":"iresult"}}],[5,"newline","","",null,null],[5,"crlf","","",null,null],[5,"eol","","",null,null],[5,"tab","","",null,null],[5,"anychar","","",null,null],[5,"shift","","",null,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"hash","","",0,null],[11,"clone","","",0,null],[11,"description","","",0,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"clone","","",1,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"clone","","",2,null],[11,"is_known","","",2,null],[11,"map","","Maps a `Needed` to `Needed` by appling a function to a contained `Size` value.",2,null],[11,"fmt","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"is_done","","",3,null],[11,"is_err","","",3,null],[11,"is_incomplete","","",3,null],[11,"map","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, N, E&gt;` by appling a function\nto a contained `Done` value, leaving `Error` and `Incomplete` value\nuntouched.",3,null],[11,"map_inc","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, E&gt;` by appling a function\nto a contained `Incomplete` value, leaving `Done` and `Error` value\nuntouched.",3,null],[11,"map_err","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, N&gt;` by appling a function\nto a contained `Error` value, leaving `Done` and `Incomplete` value\nuntouched.",3,null],[11,"unwrap","","Unwrap the contained `Done(I, O)` value, or panic if the `IResult` is not\n`Done`.",3,null],[11,"unwrap_inc","","Unwrap the contained `Done(I, O)` value, or panic if the `IResult` is not\n`Done`.",3,null],[11,"unwrap_err","","Unwrap the contained `Done(I, O)` value, or panic if the `IResult` is not\n`Done`.",3,null],[11,"remaining_input","","",3,null],[11,"remaining_input","","",3,null],[11,"remaining_input","","",3,null],[11,"output","","",3,null],[11,"output","","",3,null],[11,"output","","",3,null],[11,"description","","",1,null],[11,"fmt","","",1,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"map","","",5,null],[11,"flat_map","","",5,null],[11,"apply","","",8,null],[11,"new","","",9,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"apply","","",9,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"eq","","",7,null],[11,"fmt","","",10,null],[11,"new","","",10,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"state","","",10,null],[11,"refill","","",10,null],[11,"resize","","Resize the internal buffer, copy the data to the new one and returned how much data was copied",10,null],[11,"apply","","",10,null],[11,"new","","",11,{"inputs":[{"name":"c"},{"name":"f"}],"output":{"name":"mapconsumer"}}],[11,"handle","","",11,null],[11,"state","","",11,null],[11,"new","","",12,{"inputs":[{"name":"c1"},{"name":"c2"}],"output":{"name":"chainconsumer"}}],[11,"handle","","",12,null],[11,"state","","",12,null],[8,"HexDisplay","","useful functions to calculate the offset between slices and show a hexdump of a slice",null,null],[10,"offset","","offset between the first byte of self and the first byte of the argument",13,null],[10,"to_hex","","Converts the value of `self` to a hex dump, returning the owned\nstring.",13,null],[10,"to_hex_from","","Converts the value of `self` to a hex dump beginning at `from` address, returning the owned\nstring.",13,null],[8,"InputLength","","",null,null],[10,"input_len","","",14,null],[8,"AsChar","","",null,null],[10,"as_char","","",15,null],[10,"is_alpha","","",15,null],[10,"is_alphanum","","",15,null],[10,"is_0_to_9","","",15,null],[10,"is_hex_digit","","",15,null],[10,"is_oct_digit","","",15,null],[8,"IterIndices","","",null,null],[16,"Item","","",16,null],[16,"Iter","","",16,null],[10,"iter_indices","","",16,null],[8,"AsBytes","","",null,null],[10,"as_bytes","","",17,null],[8,"GetInput","","",null,null],[10,"remaining_input","","",18,null],[8,"GetOutput","","",null,null],[10,"output","","",19,null],[8,"Consumer","","The Consumer trait wraps a computation and its state",null,null],[10,"handle","","implement handle for the current computation, returning the new state of the consumer",20,null],[10,"state","","returns the current state",20,null],[8,"Producer","","The producer wraps a data source, like file or network, and applies a consumer on it",null,null],[10,"apply","","Applies a consumer once on the produced data, and return the consumer&#39;s state",21,null],[11,"run","","Applies a consumer once on the produced data, and returns the generated value if there is one",21,null],[14,"dbg","","Prints a message if the parser fails",null,null],[14,"dbg_dmp","","Prints a message and the input if the parser fails",null,null],[14,"closure","","Wraps a parser in a closure",null,null],[14,"named","","Makes a function from a parser combination",null,null],[14,"call","","Used to wrap common expressions and function as macros",null,null],[14,"apply","","emulate function currying: `apply!(my_function, arg1, arg2, ...)` becomes `my_function(input, arg1, arg2, ...)`",null,null],[14,"error","","Prevents backtracking if the child parser fails",null,null],[14,"add_error","","Add an error if the child parser fails",null,null],[14,"fix_error","","translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type",null,null],[14,"complete","","replaces a `Incomplete` returned by the child parser\nwith an `Error`",null,null],[14,"try_parse","","A bit like `std::try!`, this macro will return the remaining input and parsed value if the child parser returned `Done`,\nand will do an early return for `Error` and `Incomplete`\nthis can provide more flexibility than `chain!` if needed",null,null],[14,"flat_map","","`flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;`",null,null],[14,"map","","`map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function on the result of a parser",null,null],[14,"map_res","","`map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function returning a Result on the output of a parser",null,null],[14,"map_opt","","`map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function returning an Option on the output of a parser",null,null],[14,"value","","`value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;`",null,null],[14,"expr_res","","`expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nevaluate an expression that returns a Result&lt;T,E&gt; and returns a IResult::Done(I,T) if Ok",null,null],[14,"expr_opt","","`expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nevaluate an expression that returns a Option&lt;T&gt; and returns a IResult::Done(I,T) if Some",null,null],[14,"chain","","`chain!(I-&gt;IResult&lt;I,A&gt; ~ I-&gt;IResult&lt;I,B&gt; ~ ... I-&gt;IResult&lt;I,X&gt; , || { return O } ) =&gt; I -&gt; IResult&lt;I, O&gt;`\nchains parsers and assemble the results through a closure",null,null],[14,"tuple","","`tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;`\nchains parsers and assemble the sub results in a tuple.",null,null],[14,"alt","","`alt!(I -&gt; IResult&lt;I,O&gt; | I -&gt; IResult&lt;I,O&gt; | ... | I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;`\ntry a list of parsers, return the result of the first successful one",null,null],[14,"alt_complete","","This is a combination of the `alt!` and `complete!` combinators. Rather\nthan returning `Incomplete` on partial input, `alt_complete!` will try the\nnext alternative in the chain. You should use this only if you know you\nwill not receive partial input for the rules you&#39;re trying to match (this\nis almost always the case for parsing programming languages).",null,null],[14,"switch","","`switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;`\nchoose the next parser depending on the result of the first one, if successful,\nand returns the result of the second parser",null,null],[14,"opt","","`opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nmake the underlying parser optional",null,null],[14,"opt_res","","`opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;`\nmake the underlying parser optional",null,null],[14,"cond_with_error","","`cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nConditional combinator",null,null],[14,"cond","","`cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nConditional combinator",null,null],[14,"cond_reduce","","`cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nConditional combinator with error",null,null],[14,"peek","","`peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns a result without consuming the input",null,null],[14,"not","","`not!(I -&gt; IResult&lt;I,0&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns a result only if the embedded parser returns Error or Incomplete\ndoes not consume the input",null,null],[14,"tap","","`tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;`\nallows access to the parser&#39;s result without affecting it",null,null],[14,"pair","","`pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;`\npair(X,Y), returns (x,y)",null,null],[14,"separated_pair","","`separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;`\nseparated_pair(X,sep,Y) returns (x,y)",null,null],[14,"preceded","","`preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\npreceded(opening, X) returns X",null,null],[14,"terminated","","`terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nterminated(X, closing) returns X",null,null],[14,"delimited","","`delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\ndelimited(opening, X, closing) returns X",null,null],[14,"separated_list","","`separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nseparated_list(sep, X) returns Vec&lt;X&gt;",null,null],[14,"separated_nonempty_list","","`separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nseparated_nonempty_list(sep, X) returns Vec&lt;X&gt;",null,null],[14,"many0","","`many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"many1","","`many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"many_m_n","","`many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser between m and n times (n included) and returns the list of results in a Vec",null,null],[14,"count","","`count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the child parser a specified number of times",null,null],[14,"count_fixed","","`count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;`\nApplies the child parser a fixed number of times and returns a fixed size array\nThe type must be specified and it must be `Copy`",null,null],[14,"length_value","","`length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\ngets a number from the first parser, then applies the second parser that many times",null,null],[14,"fold_many0","","`fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser 0 or more times and folds the list of return values",null,null],[14,"fold_many1","","`fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser 1 or more times and folds the list of return values",null,null],[14,"fold_many_m_n","","`fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser between m and n times (n included) and folds the list of return value",null,null],[14,"method","","Makes a method from a parser combination",null,null],[14,"call_m","","Used to called methods then move self back into self",null,null],[14,"apply_m","","emulate function currying for method calls on structs\n`apply!(self.my_function, arg1, arg2, ...)` becomes `self.my_function(input, arg1, arg2, ...)`",null,null],[14,"recognize","","`recognize!(&amp;[T] -&gt; IResult&lt;&amp;[T], O&gt; ) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nif the child parser was successful, return the consumed input as produced value",null,null],[14,"tag","","`tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ndeclares a byte array as a suite to recognize",null,null],[14,"is_not","","`is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a","","`is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes that appear in the provided array",null,null],[14,"escaped","","`escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nmatches a byte string with escaped characters.",null,null],[14,"escaped_transform","","`escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;`\nmatches a byte string with escaped characters.",null,null],[14,"take_while","","`take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"take_while1","","`take_while1!(&amp;[T] -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest (non empty) list of bytes until the provided function fails.",null,null],[14,"take_till","","`take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes until the provided function succeeds",null,null],[14,"take","","`take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"take_str","","`take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;`\nsame as take! but returning a &amp;str",null,null],[14,"take_until_and_consume","","`take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ngenerates a parser consuming bytes until the specified byte sequence is found, and consumes it",null,null],[14,"take_until","","`take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nconsumes data until it finds the specified tag",null,null],[14,"take_until_either_and_consume","","`take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nconsumes data until it finds any of the specified characters, and consume it",null,null],[14,"take_until_either","","`take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`",null,null],[14,"length_bytes","","`length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;\ngets a number from the first parser, then extracts that many bytes from the\nremaining stream",null,null],[14,"bits","","`bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;`\ntransforms its byte slice input into a bit stream for the underlying parsers",null,null],[14,"take_bits","","`take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;`\ngenerates a parser consuming the specified number of bits.",null,null],[14,"tag_bits","","matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified",null,null],[14,"u16","","if parameter is true, parse a big endian u16 integer,\notherwise a little endian u16 integer",null,null],[14,"u32","","if parameter is true, parse a big endian u32 integer,\notherwise a little endian u32 integer",null,null],[14,"u64","","if parameter is true, parse a big endian u64 integer,\notherwise a little endian u64 integer",null,null],[14,"i16","","if parameter is true, parse a big endian i16 integer,\notherwise a little endian i16 integer",null,null],[14,"i32","","if parameter is true, parse a big endian i32 integer,\notherwise a little endian i32 integer",null,null],[14,"i64","","if parameter is true, parse a big endian i64 integer,\notherwise a little endian i64 integer",null,null],[14,"one_of","","matches one of the provided characters",null,null],[14,"none_of","","matches anything but the provided characters",null,null],[14,"char","","matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;",null,null],[14,"consumer_from_parser","","",null,null],[14,"tag_s","","`tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ndeclares a string as a suite to recognize",null,null],[14,"take_s","","`take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming the specified number of characters",null,null],[14,"is_not_s","","`is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters that do not appear in the provided array",null,null],[14,"is_a_s","","`is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters that appear in the provided array",null,null],[14,"take_while_s","","`take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters until the provided function fails.",null,null],[14,"take_while1_s","","`take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest (non empty) list of characters until the provided function fails.",null,null],[14,"take_till_s","","`take_till_s!(&amp;str -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters until the provided function succeeds",null,null],[14,"take_until_and_consume_s","","`take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming all chars until the specified string is found and consumes it",null,null],[14,"take_until_s","","`take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming all chars until the specified string is found and leaves it in the remaining input",null,null],[11,"run","","Applies a consumer once on the produced data, and returns the generated value if there is one",21,null]],"paths":[[4,"ErrorKind"],[4,"Err"],[4,"Needed"],[4,"IResult"],[4,"Input"],[4,"ConsumerState"],[4,"Move"],[4,"FileProducerState"],[3,"ProducerRepeat"],[3,"MemProducer"],[3,"FileProducer"],[3,"MapConsumer"],[3,"ChainConsumer"],[8,"HexDisplay"],[8,"InputLength"],[8,"AsChar"],[8,"IterIndices"],[8,"AsBytes"],[8,"GetInput"],[8,"GetOutput"],[8,"Consumer"],[8,"Producer"]]};
searchIndex["quote"] = {"doc":"","items":[[3,"Tokens","quote","",null,null],[3,"ByteStr","","",null,null],[12,"0","","",0,null],[11,"fmt","","",1,null],[11,"new","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"append","","",1,null],[11,"append_separated","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",1,null],[11,"fmt","","",0,null],[11,"to_tokens","","",0,null],[11,"to_tokens","","",1,null],[8,"ToTokens","","",null,null],[10,"to_tokens","","",2,null],[14,"quote","","",null,null]],"paths":[[3,"ByteStr"],[3,"Tokens"],[8,"ToTokens"]]};
initSearch(searchIndex);
